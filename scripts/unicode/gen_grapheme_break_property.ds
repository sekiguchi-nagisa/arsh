#!/usr/bin/env arsh

if $# != 1 {
    echo "[usage] $0 [output]" 1>&2
    exit 1
}

command -v curl &> /dev/null || { echo require curl 1>&2; exit 1; }

let out = $1.startsWith("/") ? $1 : "../$1"
let work_dir = "grapheme-temp"

test -d $work_dir || mkdir $work_dir

cd $work_dir

test -f GraphemeBreakProperty.txt ||
    curl http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt -o ./GraphemeBreakProperty.txt

typedef Range {
    let begin : Int         # begin codepoint (inclusive)
    let end : Int           # end codepoint (inclusive)
    let begin_str : String  # begin codepoint string
    let end_str : String    # end codepoint string
    let property : String   # property string
}

function compare(o : Range) : Int for Range {
    return $this.end.compare($o.begin)
}

function try_merge(o : Range) : Range? for Range {
    if $this.end + 1 == $o.begin && $this.property == $o.property {
        # merge range
        return new Range(
            $this.begin,
            $o.end,
            $this.begin_str,
            $o.end_str,
            $this.property
        )
    }
    return $none
}

function parse($line : String) : Range {
    var m = $/^([0-9A-F]+)(\.\.([0-9A-F]+))?[ ]+;[ ]+([a-zA-Z0-9_]+)[ ]*#.+$/.match($line)!
    var begin = "0x${$m.group(1)!}"
    var end = "0x${$m.group(3) ?? $m.group(1)!}"
    var p = $m.group(4)!

    var ret = new Range(
        $begin.toInt()!,
        $end.toInt()!,
        $begin,
        $end,
        $p
    )
    assert $ret.begin <= $ret.end
    return $ret
}

function validate(ranges: [Range]) {
    var prev : Range?
    for r in $ranges {
        if $prev {
            assert $prev!.begin < $r.begin
            assert $prev!.end < $r.end
            assert $prev!.end < $r.begin
        }
        $prev = $r
    }
}

function minimize($ranges : [Range]) : [Range] {
    $validate($ranges)
    var ret : [Range]
    for $r in $ranges {
        if $ret.empty() {
            $ret.add($r)
            continue
        }
        if let n = $ret.peek().try_merge($r) {
            $ret.pop()
            $ret.push($n)
            continue
        }
        $ret.add($r)
    }
    $validate($ret)
    return $ret
}


 {
    echo "/* Auto-generated by scripts/unicode/$(basename $0)  */"
    echo "/*"
 } with > $out

var ranges : [Range]

# GraphemeBreakProperty.txt
cat ./GraphemeBreakProperty.txt | for(var count = 0; read -f $'\n'; $count++) {
    if $count < 2 {
        echo $REPLY >> $out
        continue
    }

    if $REPLY.startsWith('#') || $REPLY.empty() {
        continue
    }
    try { $ranges.add($parse($REPLY)); } catch $e : Error { $e.show(); echo 1>&2 $count $REPLY; }
    echo $REPLY
} with > ./trimed_GraphemeBreakProperty.txt 


$ranges.sortBy(function (x,y) => $x.compare($y))
$ranges = $minimize($ranges)

# final output
{
    echo "*/"
    echo
    echo // clang-format off
    echo "static constexpr UNICODE_PROPERTY_RANGE grapheme_break_property_table[] = {"

    let size = $ranges.size()
    if $ranges[0].begin > 0 {
        echo "    { 0x0000, PROPERTY(Any) },"
    }
    for(var i = 0; $i < $size; $i++) {
        var r = $ranges[$i]
        if $i > 0 && $ranges[$i-1].end + 1 < $r.begin {  # fill Any
            printf "    { 0x%04X, PROPERTY(Any) },\n" ${$ranges[$i-1].end+1}
        }
        echo "    { ${r.begin_str}, PROPERTY(${r.property}) },"
    }

    echo -e "};"
} with >> $out