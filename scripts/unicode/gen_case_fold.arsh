#!/usr/bin/env arsh

if $# != 1 {
    echo "[usage] $0 [output]" 1>&2
    exit 1
}

command -v curl &> /dev/null || { echo require curl 1>&2; exit 1; }

let out = $1.startsWith("/") ? $1 : "../$1"
let work_dir = "case-fold-temp"

test -d $work_dir || mkdir $work_dir

cd $work_dir

test -f CaseFolding.txt ||
    curl https://www.unicode.org/Public/UCD/latest/ucd/CaseFolding.txt -o ./CaseFolding.txt


type Entry {
    let codeStr: String
    let status: String
    let mappingStr: [String]
    let code: Int
    let mapping: Int?
}

function parse(line: String) : Entry {
    # <code>; <status>; <mapping>; # <name>
    let ret = $/^(?<code>[0-9A-F]+); (?<status>[CFST]); (?<mapping>[0-9A-F]+( [0-9A-F]+)*); #.+$/.match($line)!
    var codeStr = "0x${$ret.named('code')!}"
    var code = $codeStr.toInt()!
    var status = $ret.named('status')!
    var mappingStr : [String]
    var mapping : Int?
    for v in $ret.named('mapping')!.split(' ') {
        $mappingStr.add("0x$v")
    }

    ## validate
    assert !$mappingStr.empty()
    if $mappingStr.size() == 1 {
        $mapping = $mappingStr[0].toInt()
        if $code <= 0xFFFF {
            assert $mapping! <= 0xFFFF
        } elif $code <= 0xFFFFFFFF && $code > 0xFFFF {
            assert $mapping! <= 0xFFFFFFFF
        } else {
            assert $false
        }
    } else {
        assert $code <= 0xFFFF
        for v in $mappingStr {
            assert $v.toInt()! <= 0xFFFF
        }
    }
    return new Entry($codeStr, $status, $mappingStr, $code, $mapping)
}

var shortC : [Entry]
var longC : [Entry]
var S: [Entry]
var F: [Entry]
var T: [Entry]

var headers : [String]

for line in new FD('./CaseFolding.txt') {
    $line.empty() && continue
    if $line.startsWith('#') {
        if $headers.size() < 2 {
            $headers.add($line)
        }
        continue
    }

    var entry = $parse($line)
    case $entry.status {
        'C' => {
            assert $entry.mapping
            assert $entry.mappingStr.size() == 1
            if $entry.code <= 0xFFFF {
                $shortC.add($entry)
            } else {
                $longC.add($entry)
            }
        }
        'S' => {
            assert $entry.mapping
            assert $entry.mappingStr.size() == 1
            assert $entry.code <= 0xFFFF
            assert $entry.mapping! <= 0xFFFF
            $S.add($entry)
        }
        'F' => {
            assert $entry.mappingStr.size() > 1
            assert $entry.code <= 0xFFFF
            $F.add($entry)
        }
        'T' => {
            assert $entry.mapping
            assert $entry.mappingStr.size() == 1
            assert $entry.code <= 0xFFFF
            assert $entry.mapping! <= 0xFFFF
            $T.add($entry)
        }
        else => { assert $false: "invalid status"; }
    }
}

assert !$shortC.empty()
assert !$longC.empty()
assert !$S.empty()
assert !$F.empty()
assert !$T.empty()

## generate code
function comp(x: Entry, y: Entry): Int {
    return $x.code.compare($y.code)
}
$shortC.sortBy($comp)
$longC.sortBy($comp)
$S.sortBy($comp)
$F.sortBy($comp)
$T.sortBy($comp)

function emitTable(entries: [Entry], name: String) {
    echo
    echo "static constexpr CASE_FOLD_${name}_ENTRY case_fold_${name}_table[] = {"
    for e in $entries {
        echo "    { ${$e.codeStr}, ${$e.mappingStr[0]} },"
    }
    echo "};"
}

function emitTable2(entries: [Entry], name: String) {
    # resolve max mapping length
    var size = 0
    for e in $entries {
        if $e.mappingStr.size() > $size {
            $size = $e.mappingStr.size()
        }
    }

    echo
    echo "static constexpr CASE_FOLD_${name}_ENTRY case_fold_${name}_table[] = {"
    for e in $entries {
        var m = $e.mappingStr.join(', ')
        var diff = $size - $e.mappingStr.size()
        for(var i = 0; $i < $diff; $i++) {
            $m += ", 0x0000";
        }
        echo "    { ${$e.codeStr}, $m },"
    }
    echo "};"
}

{
    echo "/* Auto-generated by scripts/unicode/$(basename $0) */"
    echo "/*"
    for h in $headers {
        echo $h
    }
    echo "*/"
    echo
    echo // clang-format off
    $emitTable($shortC, 'shortC')
    $emitTable($longC, 'longC')
    $emitTable($S, 'S')
    $emitTable2($F, 'F')
    $emitTable($T, 'T')

} with > $out