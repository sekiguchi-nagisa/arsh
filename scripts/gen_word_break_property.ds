#!/usr/bin/env arsh

if $# != 1 {
    echo "[usage] $0 [output]" 1>&2
    exit 1
}

command -v curl &> /dev/null || { echo require curl 1>&2; exit 1; }

let out = $1.startsWith("/") ? $1 : "../$1"
let work_dir = "word-temp"

test -d $work_dir || mkdir $work_dir

cd $work_dir

test -f WordBreakProperty.txt ||
    curl http://www.unicode.org/Public/UCD/latest/ucd/auxiliary/WordBreakProperty.txt -o ./WordBreakProperty.txt

test -f emoji-data.txt ||
    curl https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt -o emoji-data.txt


typedef Range = (
    Int,    # begin codepoint
    Int,    # end codepoint
    String, # begin codepoint string
    String, # end codepoint string
    String  # property string
)

function rangeComp($x : Range, $y : Range) : Int {
    return $x._1.compare($y._0)
}

function parse($line : String) : Range {
    var m = $/^([0-9A-F]+)(\.\.([0-9A-F]+))?[ ]+;[ ]+([a-zA-Z0-9_]+)[ ]*#.+$/.match($line)!
    var begin = "0x${$m.group(1)!}"
    var end = "0x${$m.group(3) ?? $m.group(1)!}"
    var p = $m.group(4)!

    return (
        $begin.toInt()!,
        $end.toInt()!,
        $begin,
        $end,
        $p
    )
}

function validate($ranges : [Range]) {
    var prev : Range?
    for r in $ranges {
        if $prev {
            assert $prev!._0 < $r._0: "prev:${$prev!}, cur:${$r}"
            assert $prev!._1 < $r._1: "prev:${$prev!}, cur:${$r}"
        }
        $prev = $r
    }
}

function minimize($ranges : [Range]) : [Range] {
    $validate($ranges)
    var ret : [Range]
    for $r in $ranges {
        if $ret.empty() {
            $ret.add($r)
            continue
        }
        var p = $ret.peek()
        if $p._1 + 1 == $r._0 && $p._4 == $r._4 {
            # merge range
            $p._1 = $r._1
            $p._3 = $r._3
            continue
        }
        $ret.add($r)
    }
    $validate($ret)
    return $ret
}


 {
    echo "/* Auto-generated by scripts/$(basename $0)  */"
    echo "/*"
 } with > $out

var ranges : [Range]

# WordBreakProperty.txt
cat ./WordBreakProperty.txt | for(var count = 0; read -f $'\n'; $count++) {
    if $count < 2 {
        echo $REPLY >> $out
        continue
    }

    if $REPLY.startsWith('#') || $REPLY.empty() {
        continue
    }
    try { $ranges.add($parse($REPLY)); } catch $e : Error { $e.show(); echo 1>&2 $count $REPLY; }
    echo $REPLY
} with > ./trimed_WordBreakProperty.txt

$ranges.sortBy($rangeComp)
$ranges = $minimize($ranges)

# emoji-data.txt
var ranges2: [Range]
cat ./emoji-data.txt | for(var count = 0; read -f $'\n'; $count++) {
    if $count < 2 {
        echo $REPLY >> $out
        continue
    }

    if $REPLY.startsWith('#') || $REPLY.empty() || $REPLY.indexOf("Extended_Pictographic") == -1 {
        continue
    }
    try { $ranges2.add($parse($REPLY)); } catch $e : Error { $e.show(); echo 1>&2 $count $REPLY; }
    echo $REPLY
} with > ./trimed_emoji-data.txt

$ranges2.sortBy($rangeComp)
$ranges2 = $minimize($ranges2)

# final output
{
    echo "*/"
    echo
    echo // clang-format off
    echo "#ifdef USE_WORD_BREAK_PROPERTY"
    echo
    echo "static constexpr UNICODE_PROPERTY_RANGE word_break_property_table[] = {"
} with >> $out

for $r in $ranges {
    echo "    { ${$r._2}, ${$r._3}, PROPERTY(${$r._4}) },"
} with >> $out

{
    echo -e "};"
    echo
    echo "#endif"
} with >> $out


{
    echo
    echo "#ifdef USE_EMOJI_PROPERTY"
    echo
    echo "static constexpr UNICODE_PROPERTY_RANGE emoji_property_table[] = {"
} with >> $out

for $r in $ranges2 {
    echo "    { ${$r._2}, ${$r._3}, PROPERTY(${$r._4}) },"
} with >> $out

{
echo -e "};"
echo
echo "#endif"
} with >> $out
