#!/usr/bin/env ydsh

# light-weight file checker

##############################
##     helper functions     ##
##############################

function _usage($m : String) : Nothing {
    !$m.empty() && echo 1>&2 $m
    echo 1>&2 usage: litecheck [-b bin] file
    exit 2
}

function _error($m : String) : Nothing {
    echo 1>&2 $m
    exit 1
}

function _lines($path : String) : [String] {
    return IFS=$'\n' $(cat $path)
}

#####################################
##     expose to target script     ##
#####################################

var cmd = ''
var self = ''

##############################
##     actual functions     ##
##############################

let RUN = "RUN"
let CHECK = "CHECK"
let CHECKERR = "CHECKERR"
let STATUS = "STATUS"
let REQUIRE = "REQUIRE"
let SHEBANG = "#!"

typedef Directive = (
    String, # directive type (RUN, CHECK, CHECKERR, STATUS, REQUIRES)
    String, # line
    Int,    # line number
)

function _parse_num($v : String) : Int! {
    var m = $/^ *(0|[1-9][0-9]*) *$/.match($v)
    var r : Int!
    if !$m.empty() {
        $r = $m[1]!.toInt()
    }
    return $r
}

 function _parse_directives($path : String) : [String: [Directive]] {
    var map = [
        $RUN : new [Directive](),
        $REQUIRE : new [Directive](),
        $CHECK : new [Directive](),
        $CHECKERR : new [Directive](),
        $STATUS : new [Directive](),
    ]

    var lines = $_lines($path)
    if !$lines.empty() && $lines[0].startsWith($SHEBANG) {
        $map[$RUN].add(($SHEBANG, $lines[0], 1))
    }
    for(var i = 0; $i < $lines.size(); $i++) {
        var line = $lines[$i]
        var ln = $i + 1
        var matched = $/^# *(RUN|CHECK|CHECKERR|STATUS|REQUIRE): (.*)/.match($line)
        if !$matched.empty() {
            var type = $matched[1]!
            assert $type == $RUN || $type == $CHECK || $type == $CHECKERR || $type == $REQUIRE || $type == $STATUS
            $line = $matched[2]!
            $map[$type].add(($type, $line, $ln))
        }
    }

    ## check RUN directive or SHEBANG
    case $map[$RUN].size() {
        0 => $_error("require $RUN directive or shebang")
        1 => if $map[$RUN][0]._0 == $SHEBANG {
                test -x $self || $_error("must be executable: `$self'")
                $map[$RUN].shift()
             } else {
                assert $map[$RUN][0]._0 == $RUN
             }
        else => {
            if $map[$RUN][0]._0 == $SHEBANG {
                $map[$RUN].shift()
                assert $map[$RUN][0]._0 == $RUN
            }
            $map[$RUN].size() == 1 || $_error("$RUN directive has already defined")
        }
    }

    ## check STATUS directive
    case $map[$STATUS].size() {
        0 => {}
        1 => {
            var d = $map[$STATUS][0]._1
            $_parse_num($d) ?? $_error("invalid $STATUS directive: `$d'")
        }
        else => $_error("$STATUS directive has already defined")
    }
    return $map
 }

function _check_output($checks : [Directive], $output : [String]) : Bool {
    var eout = ""
    for $c in $checks {
        if !$eout.empty() {
            $eout += $'\n'
        }
        $eout += $c._1
    }
    return diff 1>&2 <(cat <<< $eout) <(cat <<< ${$output.join($'\n')})
}

function _run_and_check($map : [String : [Directive]]) : Int {
    var run = case $map[$RUN].size() {
        0 => $MODULE.func("eval $self")
        else => {
            var d = $map[$RUN][0]._1
            try {
                $MODULE.func($d)
            } catch $e : Error {
                $_error("invalid $RUN directive: `$d', caused by" + $'\n' + $e.message())
            }
        }
    }

    assert command -v mktemp > /dev/null
    let outPath = "$(mktemp)" :- $_error("mktemp failed")
    let errPath = "$(mktemp)" :- $_error("mktemp failed")

    try {
        $? = 0
        var j = ($run() with 1> $outPath 2> $errPath) &
        var s = $j.wait()
        var outs = $_lines($outPath)
        var errs = $_lines($errPath)

        var ret = 0
        if !$map[$CHECK].empty() {
            if !$_check_output($map[$CHECK], $outs) { echo 1>&2 stdout is mismatched; $ret = 1; }
        }
        if !$map[$CHECKERR].empty() {
            if !$_check_output($map[$CHECKERR], $errs) { echo 1>&2 stderr is mismatched; $ret = 1; }
        }
        if !$map[$STATUS].empty() {
            var estatus = $_parse_num($map[$STATUS][0]._1)!
            $s == $estatus || $_error("exit status is mismatched, expected: `$estatus', actual: `$s'")
        }
        return $ret
    } finally {
        rm -f $outPath
        rm -f $errPath
    }
}

# entry point
litecheck() {
    # parse command line arguments
    var bin : String!
    var file : String!
    for(var i = 0; $i < $#; $i++) {
        var arg = $@[$i]
        case $arg {
        "-b" => 
            if $i + 1 < $# {
                $i++
                $bin = $@[$i]
            } else {
                $_usage("`$arg' option requires argument")
            }
        $/^-.*/ => $_usage("invalid option: $arg")
        else => { $file = $arg; break; }
        }
    }

    ## check file existence
    $file ?? $_usage("require file")
    $self = $file!.realpath() ?? $_usage("file not found: `${$file!}'")
    test -f $self || $_usage("require regular file: ${$file!}")

    ## check bin
    if $bin {
        $cmd = $bin!.realpath() ?? $_usage("file not found: `${$bin!}'")
        (test -f $cmd && test -x $cmd) || $_usage("must be executable: `${$bin!}'")
    }

    # read directive
    var map = $_parse_directives($self)

    # check pre-condition
    for $d in $map[$REQUIRE] {
        var cond = try { $MODULE.func($d._1)(); } 
                   catch $e : Error { $_error("invalid $REQUIRE directive: `${$d._1}', caused by" + $'\n' + $e.message()); }
        $cond is Bool || $_error("$REQUIRE directive must be boolean expression: `${$d._1}'")
        $cond! as Bool || { echo skip "`$self'"; exit 125; }
    }

    # run command
    return $_run_and_check($map)
}


shctl is-sourced || litecheck $@