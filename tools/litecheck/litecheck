#!/usr/bin/env ydsh

# light-weight file checker

##############################
##     helper functions     ##
##############################

function _usage($m : String) : Nothing {
    !$m.empty() && echo 1>&2 $m
    echo 1>&2 usage: litecheck [-b bin] file
    exit 2
}

function _error($m : String) : Nothing {
    echo 1>&2 $m
    exit 1
}

function _lines($path : String) : [String] {
    return IFS=$'\n' $(cat $path)
}

#####################################
##     expose to target script     ##
#####################################

var cmd = ''
var self = ''

##############################
##     actual functions     ##
##############################

let RUN = "RUN"
let CHECK = "CHECK"
let CHECKERR = "CHECKERR"
let STATUS = "STATUS"
let REQUIRE = "REQUIRE"
let SHEBANG = "#!"

typedef Directive = (
    String, # directive type (RUN, CHECK, CHECKERR, STATUS, REQUIRES)
    String, # line
    Int,    # line number
)

function _parse_num($v : String) : Int! {
    var m = $/^ *(0|[1-9][0-9]*) *$/.match($v)
    var r : Int!
    if !$m.empty() {
        $r = $m[1]!.toInt()
    }
    return $r
}

function _parse_directive($path : String) : [Directive] {
    var ret : [Directive]

    var lines = $_lines($path)
    if !$lines.empty() && $lines[0].startsWith($SHEBANG) {
        $ret.add(($SHEBANG, $lines[0], 1))
    }
    for(var i = 0; $i < $lines.size(); $i++) {
        var line = $lines[$i]
        var ln = $i + 1
        var matched = $/^# *(RUN|CHECK|CHECKERR|STATUS|REQUIRE): (.*)/.match($line)
        if !$matched.empty() {
            var type = $matched[1]!
            assert $type == $RUN || $type == $CHECK || $type == $CHECKERR || $type == $REQUIRE || $type == $STATUS
            $line = $matched[2]!
            $ret.add(($type, $line, $ln))
        }
    }

    # validate directive order
    var has_shebang = $false
    var has_run = $false

    let size = $ret.size()
    var index = 0

    ## check shebang or RUN directive
    if $index < $size && $ret[$index]._0 == $SHEBANG {
        $has_shebang = $true
        $index++
    }
    if $index < $size && $ret[$index]._0 == $RUN {
        $index++
        $has_run = $true
    } elif $has_shebang {
    } else {
        $_error("require $RUN directive or shebang")
    }

    if !$has_run {
        test -x $self || $_error("must be executable: `$self'")
    }

    ## check STATUS directive
    var status : Int!
    for(; $index < $size; $index++) {
        var d = $ret[$index]
        if $d._0 == $STATUS {
            if $status { $_error("$STATUS directive has already defined"); }
            $status = $_parse_num($d._1) ?? $_error("invalid $STATUS directive: `${$d._1}'")
        }
    }

    if $has_shebang {
        $ret.shift()
    }
    return $ret
}

function _run_and_check($directives : [Directive]) : Int {
    var run = if !$directives.empty() && $directives[0]._0 == $RUN {
        var d = $directives.shift()
        try {
            $MODULE.func($d._1)
        } catch $e : Error {
            $e.backtrace(); 
            $_error("invalid $RUN directive: `${$d._1}'"); 
        }
    } else {
        $MODULE.func("eval $self")
    }

    assert command -v mktemp > /dev/null
    let outPath = "$(mktemp)" :- $_error("mktemp failed")
    let errPath = "$(mktemp)" :- $_error("mktemp failed")

    try {
        $? = 0
        var j = ($run() with 1> $outPath 2> $errPath) &
        var s = $j.wait()
        var outs = $_lines($outPath)
        var errs = $_lines($errPath)

        var estatus : Int!
        var eouts : [String]
        var eout_found = $false
        var eerrs : [String]
        var eerr_found = $false
        for $d in $directives {
            if $d._0 == $CHECK {
                $eouts.add($d._1)
                $eout_found = $true
            } elif $d._0 == $CHECKERR {
                $eerrs.add($d._1)
                $eerr_found = $true
            } elif $d._0 == $STATUS {
                $estatus = $_parse_num($d._1)!
            }
        }

        var ret = 0
        if $eout_found {
            var b = diff 1>&2 \
                <(cat <<< ${$eouts.join($'\n')}) \
                <(cat <<< ${$outs.join($'\n')})
            if !$b {
                echo 1>&2 stdout is mismatched
                $ret = 1
            }
        }

        if $eerr_found {
            var b = diff 1>&2 \
                <(cat <<< ${$eerrs.join($'\n')}) \
                <(cat <<< ${$errs.join($'\n')})
            if !$b {
                echo 1>&2 stderr is mismatched
                $ret = 1
            }
        }

        if $estatus {
            $s == $estatus! || $_error("exit status is mismatched, expected: `${$estatus!}', actual: `$s'")
        }
        return $ret
    } finally {
        rm -f $outPath
        rm -f $errPath
    }
}

# entry point
litecheck() {
    # parse command line arguments
    var bin : String!
    var file : String!
    for(var i = 0; $i < $#; $i++) {
        var arg = $@[$i]
        case $arg {
        "-b" => 
            if $i + 1 < $# {
                $i++
                $bin = $@[$i]
            } else {
                $_usage("`$arg' option requires argument")
            }
        $/^-.*/ => $_usage("invalid option: $arg")
        else => { $file = $arg; break; }
        }
    }

    ## check file existence
    $file ?? $_usage("require file")
    $self = $file!.realpath() ?? $_usage("file not found: `${$file!}'")
    test -f $self || $_usage("require regular file: ${$file!}")

    ## check bin
    if $bin {
        $cmd = $bin!.realpath() ?? $_usage("file not found: `${$bin!}'")
        (test -f $cmd && test -x $cmd) || $_usage("must be executable: `${$bin!}'")
    }

    # read directive
    var directives = $_parse_directive($self)

    # check pre-condition
    for $d in $directives {
        $d._0 != $REQUIRE && continue
                var cond = try { $MODULE.func($d._1)(); } 
                   catch $e : Error { $e.backtrace(); $_error("invalid $REQUIRE directive: `${$d._1}'"); }
        $cond is Bool || $_error("$REQUIRE directive must be boolean expresion: `${$d._1}'")
        $cond! as Bool || { echo skip "`$self'"; exit 125; }
    }

    # run command
    return $_run_and_check($directives)
}


shctl is-sourced || litecheck $@