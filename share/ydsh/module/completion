#!/usr/bin/env ydsh

# for tab completion

source $SCRIPT_DIR/path

typedef Completer = typeof($COMP_HOOK!)

let _compMap : [String : Completer]

function _defaultHook(ctx : Module, words : [String], cursor : Int) : [String] {
    command -v $words[0] &>> /dev/null || return new [String]()
    var cmd = $basename($words[0])
    $words[0] = $cmd
    var comp = $_compMap.get($cmd) ?? $_compMap.get("") ?? function(m, w, c) => new [String]()
    return $comp($ctx, $words, $cursor)
}

# if $cmd is empty string, treat as fallback handler
function compAdd(cmd : String, comp : Completer) : Completer! {
    $COMP_HOOK = $_defaultHook
    return $_compMap.put($cmd, $comp)
}


# for completion helper

function _usage() : Int {
    echo "usage: compdef [options]

Options:
    --cmd COMMAND          set target command
    --short SHORT_OPTION   set short option
    --long LONG_OPTION     set long option
    --arg-list LIST        generate candidates from LIST split by ' '
    --arg-cmd CMDLINE      generate candidates from CMDLINE evaluation
    --arg-action ACTION    generate candidates from ACTION
    --comp-path            set bash completion script
    --comp-target          set completion function
    -h, --help             show this help message"

    return 2;
}

function _require($opt : String, $msg : String) : Int {
    {
        $msg := "argument"
        echo $opt needs $msg
        return $_usage()
    } with 1>&2
}

typedef _CompDef(o : String!, t : Int!, a : String!) {
    let option = $o ?? ""   # option (length 0: empty, 1: short, 2<=: long, other)
    let type = $t ?? -1     # arg type (-1: empty, 0: list, 1: cmdline, 2: action, 3: comp)
    let arg = $a ?? ""      # argument
}

let _compdefMap : [
    String :        # command name
    [ _CompDef ]
]


#
# $prefix starts with '-'
#
function _comp_opt(deflist : [_CompDef], prefix : String) : [String] {
    var ret = new [String]()
    for def in $deflist {
        var opt = case $def.option.size() {
            0 => continue
            1 => '-' + $def.option
            else => '--' + $def.option
        }
        if $opt.startsWith($prefix) {
            $ret.add($opt)
        } elif $opt.startsWith("--") && $opt[-1] == "=" {
            # opt -> --opt=
            # prefix -> --opt=hoge
            if $prefix.startsWith($opt) {
                $ret.add($opt)
            }
        }
    }
    return $ret
}

startwith() {
    for $line in $STDIN {
        $line.startsWith($1) && echo $line
    }
}

#
# complete arguments of specified option
# $opt is empty string or starts with '-'
#
function _comp_arg(ctx : Module, deflist: [_CompDef], opt : String, prefix : String) : [String] {
    for def in $deflist {
        $opt == case $def.option.size() {
            0 => ""
            1 => '-' + $def.option
            else => '--' + $def.option
        } || continue

        var arg = $def.arg
        return case $def.type {
            0 => {
                var r : [String]
                for a in $arg.split(" ") {
                    if $a.startsWith($prefix) {
                        $r.add($a)
                    }
                }
                $r
            }
            1 => $(eval $YDSH_BIN -c "$arg" | startwith $prefix)
            2 => {
                var args : [String]
                for a in $arg.split("|") {
                    $args.add("-A")
                    $args.add($a)
                }
                complete -q -m $ctx $args $prefix;
                $COMPREPLY
            }
            else => break
        }
    }
    return new [String]()
}

let _bash_completion_dirs = [
    '/etc/bash_completion.d/',
    '/usr/share/bash-completion/completions/',
    '/usr/local/etc/bash_completion.d/',
    '/usr/local/share/bash-completion/completions/',

    '/opt/homebrew/etc/bash_completion.d/',
    '/opt/homebrew/share/bash-completion/completions/',
]

function findBashCompScript(name : String) : String! {
    for dir in $_bash_completion_dirs {
        var path = $dir + $name
        test -f $path && return $path
    }
    return new String!()
}

let _bash_completion_paths = [
    "/usr/share/bash-completion/bash_completion",
    "/usr/local/share/bash-completion/bash_completion",
    "/opt/homebrew/share/bash-completion/bash_completion",
]

var BASH_COMPLETION_PATH = "/usr/share/bash-completion/bash_completion"

# Conceptually based on git-completion.tcsh 
# (https://github.com/git/git/blob/master/contrib/completion/git-completion.tcsh)
function _comp_wrap(file : String, target : String, words : [String], cursor : Int): [String] {
    test -f $file || return new [String]()
    test -f $BASH_COMPLETION_PATH || return new [String]()
    if !(test -f $BASH_COMPLETION_PATH) {
        $BASH_COMPLETION_PATH = 
            for path in $_bash_completion_paths {
                test -f $path && break $path
            } ?? return new [String]()
    }

    let script = '
    complete() { true; }   # ignore `complete` function
    compopt() { true; }    # FIXME: emulate `-o option`
    BASH_COMPLETION_COMPAT_DIR=/dev/null
    BASH_COMPLETION_USER_FILE=/dev/null

    bash_completion_path="$1"
    comp_script="$2"
    comp_func="$3"
    COMP_CWORD="$4"
    shift 4
    COMP_WORDS=("$@")
    if [ ${#COMP_WORDS[@]} -eq $COMP_CWORD ]; then
        COMP_WORDS+=("")
    fi
    COMP_LINE="${COMP_WORDS[@]}"
    COMP_POINT=${#COMP_LINE}

    # load script and call completion function
    source "$bash_completion_path"
    source "$comp_script"
    "$comp_func" "$(basename ${COMP_WORDS[0]})"

    for r in "${COMPREPLY[@]}"; do
        printf "%s\n" "$r"
    done
    '

    var ret = IFS=$' \n' $(bash -c $script bash $BASH_COMPLETION_PATH $file $target $cursor $words)
    if $ret.size() == 1 && test -d $ret[0] && $ret[0][-1] != '/' && $ret[0].contains("/") {
        $ret[0] += "/"
    }
    return $ret
}

# for lazy loading bash completion script
function _comp_autoload(cmd : String) : String! {
    var path = $findBashCompScript($cmd) ?? return new String!()

    # find actual completion target
    var target = for line in $STDIN {
        if $/ *complete( +.+)? +-F +/ =~ $line {
            var foundF = $false
            break for ss in $line.split(' ') {
                if $foundF {
                    $ss.startsWith('_') && break $ss
                } elif $ss == '-F' {
                    $foundF = $true
                }
            }
        }
    } with < $path

    if $target {
        eval compdef --cmd $cmd --comp-path $cmd --comp-target $target && return $cmd
    }
    return new String!()
}

function _from_compdef(ctx : Module, words : [String], cursor : Int) : [String] {
    var cmd = $words[0]
    var deflist = $_compdefMap.get($cmd) ?? {
        $cmd = $_comp_autoload($cmd) ?? return new [String]()
        $_compdefMap[$cmd]
    }
    if $deflist[0].type == 3 {
        return $_comp_wrap($deflist[0].option, $deflist[0].arg, $words, $cursor)
    }

    if $words.size() == $cursor {    # complete arguments or options
        # 'CMD '
        # 'CMD arg '
        # 'CMD -s '
        var prev = $words.size() == 1 ? "" : $words[-1]
        return $_comp_arg($ctx, $deflist, $prev.startsWith("-") ? $prev : "", "")
    } else {
        # 'CMD d'
        # 'CMD -'
        # 'CMD --d'
        # 'CMD -s d'
        # 'CMD arg1 d'
        assert $words.size() > 1
        var prev = $words[-1]
        if $prev.startsWith('-') { # 'CMD -', 'CMD --d'
            var ret = $_comp_opt($deflist, $prev)
            if $ret.size() == 1 {
                var opt = $ret[0]
                if $opt.startsWith("--") && $opt[-1] == "=" {
                    # for `--opt=' style option
                    $prev = $prev.slice($opt.size())
                    return $_comp_arg($ctx, $deflist, $opt, $prev)
                }
            }
            return $ret
        }
        var opt = $words.size() == 2 ? "" : $words[-2]
        return $_comp_arg($ctx, $deflist, $opt.startsWith("-") ? $opt : "", $prev)
    }
}

compdef() {
    $@.empty() && return ($_usage() with 1>&2)
    $compAdd("", $_from_compdef)

    var cmd : String!
    var opt : String!
    var arg : String!
    var argType : Int!

    for(var i = 0; $i < $#; $i++) {
        var v = $@[$i]
        case $v {
        '--cmd' => {
            $cmd = $@.get($i + 1) ?? return $_require($v, "")
            $i++
        }
        '--short' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            $opt!.size() == 1 || return $_require($v, "single character argument")
            $i++
        }
        '--long' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            $opt!.size() > 1 || return $_require($v, "two or more characters argument")
            $i++
        }
        '--comp-path' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            if !$opt!.contains('/') {   # if not full-path, resolve full-path
                $opt = $findBashCompScript($opt!) ?? return 1; # do nothing
            }
            $i++
        }
        '--arg-list' | '--arg-cmd' | '--arg-action' | "--comp-target" => {
            $arg = $@.get($i + 1) ?? return $_require($v, "")
            $argType = case $v {
                '--arg-list' => 0
                '--arg-cmd' => 1
                '--arg-action' => 2
                '--comp-target' => 3
                else => -1
            }
            $i++
        }
        '-h' | '--help' => return { $_usage(); 0; }
        else => return ({ echo invalid option: $v; $_usage(); } with 1>&2)
        }
    }

    $cmd ?? { echo 1>&2 require --cmd option; return 1; }
    !$opt && !$arg && return 0 # do nothing

    var deflist = $_compdefMap.get($cmd!) ?? {
        var tmp : [_CompDef]
        $_compdefMap[$cmd!] = $tmp
        $tmp
    }

    $deflist.add(new _CompDef($opt, $argType, $arg))
}

function compDelegate(ctx : Module, words : [String], cursor : Int) : [String] {
    return $_defaultHook($ctx, $words, $cursor)
}
