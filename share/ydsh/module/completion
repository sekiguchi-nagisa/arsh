#!/usr/bin/env ydsh

# for tab completion

source $SCRIPT_DIR/path

function _empty(ctx : Module, words : [String], cursor : Int) : [String] {
    return new [String]()
}

typedef Completer = typeof($_empty)

let _compMap : [String : Completer]

function _defaultHook(ctx : Module, words : [String], cursor : Int) : [String] {
    if !(command -v $words[0] 2>&1 > /dev/null) {
        return new [String]()
    }
    var cmd = $basename($words[0])
    $words[0] = $cmd
    var comp = $_compMap.get($cmd) ?? $_compMap.get("") ?? $_empty
    return $comp($ctx, $words, $cursor)
}

# if $cmd is empty string, treat as fallback handler
function compAdd(cmd : String, comp : Completer) : Completer! {
    $COMP_HOOK = $_defaultHook
    return $_compMap.put($cmd, $comp)
}


# for completion helper

function _usage() : Int {
    echo "usage: compdef [options]

Options:
    --cmd COMMAND          set target command
    --short SHORT_OPTION   set short option
    --long LONG_OPTION     set long option
    --arg-list LIST        generate candidates from LIST split by ' '
    --arg-cmd CMDLINE      generate candidates from CMDLINE evaluation
    --arg-action ACTION    generate candidates from ACTION
    --comp-path            set bash completion script
    --comp-target          set completion function
    -h, --help             show this help message"

    return 2;
}

function _require($opt : String, $msg : String) : Int {
    {
        $msg := "argument"
        echo $opt needs $msg
        return $_usage()
    } with 1>&2
}

typedef _CompDef(o : String!, t : Int!, a : String!) {
    let option = $o ?? ""   # option (length 0: empty, 1: short, 2<=: long, other)
    let type = $t ?? -1     # arg type (-1: empty, 0: list, 1: cmdline, 2: action, 3: comp)
    let arg = $a ?? ""      # argument
}

let _compdefMap : [
    String :        # command name
    [ _CompDef ]
]


#
# $prefix starts with '-'
#
function _comp_opt(deflist : [_CompDef], prefix : String) : [String] {
    var ret = new [String]()
    for def in $deflist {
        var opt = case $def.option.size() {
            0 => continue
            1 => '-' + $def.option
            else => '--' + $def.option
        }
        if $opt.startsWith($prefix) {
            $ret.add($opt)
        } elif $opt.startsWith("--") && $opt[-1] == "=" {
            # opt -> --opt=
            # prefix -> --opt=hoge
            if $prefix.startsWith($opt) {
                $ret.add($opt)
            }
        }
    }
    return $ret
}

startwith() {
    for $line in $STDIN {
        $line.startsWith($1) && echo $line
    }
}

#
# complete arguments of specified option
# $opt is empty string or starts with '-'
#
function _comp_arg(ctx : Module, deflist: [_CompDef], opt : String, prefix : String) : [String] {
    for def in $deflist {
        $opt == case $def.option.size() {
            0 => ""
            1 => '-' + $def.option
            else => '--' + $def.option
        } || continue

        var arg = $def.arg
        return case $def.type {
            0 => {
                var r : [String]
                for $a in $arg.split(" ") {
                    if $a.startsWith($prefix) {
                        $r.add($a)
                    }
                }
                $r
            }
            1 => $(eval $YDSH_BIN -c "$arg" | startwith $prefix)
            2 => {
                var args : [String]
                for $a in $arg.split("|") {
                    $args.add("-A")
                    $args.add($a)
                }
                complete &> /dev/null -m $ctx $args $prefix;
                $COMPREPLY
            }
            else => break
        }
    }
    return new [String]()
}

let _bash_completion_dirs = [
    '/etc/bash_completion.d/',
    '/usr/share/bash-completion/completions/',
    '/usr/local/etc/bash_completion.d/',
    '/usr/local/share/bash-completion/completions/',

    '/opt/homebrew/etc/bash_completion.d/',
    '/opt/homebrew/share/bash-completion/completions/',
]

function findBashCompScript(name : String) : String {
    for dir in $_bash_completion_dirs {
        var path = $dir + $name
        test -f $path && return $path
    }
    return "."
}

var BCRUN_PATH = "$MODULE_HOME/bcrun/bcrun"
var BASH_COMPLETION_PATH = "/usr/share/bash-completion/bash_completion"

function _comp_wrap(file : String, target : String, words : [String], cursor : Int): [String] {
    test -f "$file" || return new [String]()
    command -v "$BCRUN_PATH" > /dev/null || return new [String]()
    test -f "$BASH_COMPLETION_PATH" || return new [String]()

    var line = ""
    for w in $words {
        if !$line.empty() { $line += " "; }
        $line += $w
    }
    if $cursor == $words.size() {
        $line += " "
    }
    var ret = $(bash "$BCRUN_PATH" "$BASH_COMPLETION_PATH" "$file" $target $line)
    if $ret.size() == 1 && test -d "${$ret[0]}" && $ret[0][-1] != '/' && $ret[0].contains("/") {
        $ret[0] += "/"
    }
    return $ret
}

function _from_compdef(ctx : Module, words : [String], cursor : Int) : [String] {
    var cmd = $words[0]
    var deflist = $_compdefMap.get($cmd) ?? return new [String]()
    if $deflist[0].type == 3 {
        return $_comp_wrap($deflist[0].option, $deflist[0].arg, $words, $cursor)
    }

    if $words.size() == $cursor {    # complete arguments or options
        # 'CMD '
        # 'CMD arg '
        # 'CMD -s '
        var prev = $words.size() == 1 ? "" : $words[-1]
        return $_comp_arg($ctx, $deflist, $prev.startsWith("-") ? $prev : "", "")
    } else {
        # 'CMD d'
        # 'CMD -'
        # 'CMD --d'
        # 'CMD -s d'
        # 'CMD arg1 d'
        assert $words.size() > 1
        var prev = $words[-1]
        if $prev.startsWith('-') { # 'CMD -', 'CMD --d'
            var ret = $_comp_opt($deflist, $prev)
            if $ret.size() == 1 {
                var opt = $ret[0]
                if $opt.startsWith("--") && $opt[-1] == "=" {
                    # for `--opt=' style option
                    $prev = $prev.slice($opt.size())
                    return $_comp_arg($ctx, $deflist, $opt, $prev)
                }
            }
            return $ret
        }
        var opt = $words.size() == 2 ? "" : $words[-2]
        return $_comp_arg($ctx, $deflist, $opt.startsWith("-") ? $opt : "", $prev)
    }
}

compdef() {
    $@.empty() && return ($_usage() with 1>&2)
    $compAdd("", $_from_compdef)

    var cmd : String!
    var opt : String!
    var arg : String!
    var argType : Int!

    for(var i = 0; $i < $#; $i++) {
        var v = $@[$i]
        case $v {
        '--cmd' => {
            $cmd = $@.get($i + 1) ?? return $_require($v, "")
            $i++
        }
        '--short' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            $opt!.size() == 1 || return $_require($v, "single character argument")
            $i++
        }
        '--long' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            $opt!.size() > 1 || return $_require($v, "two or more characters argument")
            $i++
        }
        '--comp-path' => {
            $opt = $@.get($i + 1) ?? return $_require($v, "")
            if !$opt!.contains('/') {   # if not full-path, resolve full-path
                $opt = $findBashCompScript($opt!)
            }
            $i++
        }
        '--arg-list' | '--arg-cmd' | '--arg-action' | "--comp-target" => {
            $arg = $@.get($i + 1) ?? return $_require($v, "")
            $argType = case $v {
                '--arg-list' => 0
                '--arg-cmd' => 1
                '--arg-action' => 2
                '--comp-target' => 3
                else => -1
            }
            $i++
        }
        '-h' | '--help' => return { $_usage(); 0; }
        else => return ({ echo invalid option: $v; $_usage(); } with 1>&2)
        }
    }

    $cmd ?? { echo 1>&2 require --cmd option; return 1; }
    !$opt && !$arg && return 0 # do nothing

    var deflist = $_compdefMap.get($cmd!) ?? {
        var tmp : [_CompDef]
        $_compdefMap[$cmd!] = $tmp
        $tmp
    }

    $deflist.add(new _CompDef($opt, $argType, $arg))
}

function compDelegate(ctx : Module, words : [String], cursor : Int) : [String] {
    return $_defaultHook($ctx, $words, $cursor)
}
