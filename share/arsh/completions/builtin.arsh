
source $SCRIPT_DIR/../modules/completion.arsh

function _cmd($ctx : Module, $t : [String], $c : Int) : Candidates? {
    if $t.size() == 1 || $c == 1{
        var actions = case $t[0] {
            'command' => ['-A', 'builtin', '-A', 'external']
            'exec' => ['-A', 'external']
            else => ['-A', 'command']
        }

        var prefix = $t.size() == 1 ? "" : $t.peek()
        if $prefix.contains('/') {
            $actions.add('-A').add('exec')
        }
        if $prefix.startsWith('~') {
            $actions.add('-A').add('tilde')
        }
        complete -q -d -m $ctx $actions $prefix
        return $COMPREPLY
    } else {
        $t.shift()
        return $compDelegate($ctx, $t, $c - 1)
    }
}

source $SCRIPT_DIR/../modules/fzf.arsh as _fzf

$compAdd("command", $_cmd)
$compAdd("call", $_cmd)
$compAdd("exec", $_cmd)


# defined by compdef
compdef --cmd help --arg-cmd "help | cut -d ' ' -f 1"
compdef --cmd help --short s --arg-cmd "help | cut -d ' ' -f 1"
compdef --cmd unsetenv --arg-action env
compdef --cmd getenv --arg-action env

let _option_pattern = $/^[ ]+-([a-zA-Z]) +(.+)/

## cd/pwd
compdef --cmd cd --arg-action dir
for line in <(cd -h) {
    var m = $_option_pattern.match($line) ?? continue
    compdef --cmd cd --short ${$m.group(1)!} --desc ${$m.group(2)!} --arg-action dir
}
for line in <(pwd -h) {
    var m = $_option_pattern.match($line) ?? continue
    compdef --cmd pwd --short ${$m.group(1)!} --desc ${$m.group(2)!}
}

## dirs
for line in <(dirs -h) {
    var m = $_option_pattern.match($line) ?? continue
    compdef --cmd dirs --short ${$m.group(1)!} --desc ${$m.group(2)!}
}

## kill
{
    let ff = $bindArgFunc(function(_) => new Candidates().add($_fzf.fzf_proc_select().join(' ')))
    var list = $SIG.list()
    for s in $list {
        compdef --cmd kill --long-single ${$s.name()} --arg-raw-func $ff --desc ${$s.value()}
    }
    for s in $list {
        compdef --cmd kill --long-single ${$s.value()} --arg-raw-func $ff --desc SIG${$s.name()}
    }
    compdef --cmd kill --short l --nosort
    compdef --cmd kill --short L
    compdef --cmd kill --short s --arg-action signal
    compdef --cmd kill --arg-raw-func $ff
}

## ulimit
(ulimit -h || true) | for line in $STDIN {
    var m = $_option_pattern.match($line) ?? continue
    compdef --cmd ulimit --short ${$m.group(1)!} --desc ${$m.group(2)!}
}

## complete
for line in <(complete -h) {
    var ret = $_option_pattern.match($line) ?? continue
    var o = $ret.group(1)!
    ($o == 'A' || $o == 'Q') && continue
    compdef --cmd complete --short $o --desc ${$ret.group(2)!}
}
compdef --cmd complete --short A --desc 'show completion candidates via ACTION' \
    --arg-func $bindArgFunc(function(p) => {
        var ret: Candidates
        for line in <(complete -h) {
            var matched = $/^      ([_a-z]+) +(.+)/.match($line) ?? continue
            if $matched.group(1)!.startsWith($p) {
                $ret.add($matched.group(1)!, $matched.group(2)!.split('.')[0])
            }
        }
        return $ret
    })
compdef --cmd complete --short-opt=Q --desc 'explicitly quote completion candidates' --arg-list 'arg cmd'

## fg/bg/jobs/disown
{
    var ff = $bindArgFunc(function(p)=>{
        var ret = new Candidates($sort:$false)
        for line in <(jobs -l) {
            var matched = $/^\[([0-9]+)\] +[+-]? +(.+)/.match($line) ?? continue
            var spec = '%'+$matched.group(1)!
            if $spec.startsWith($p) {
                $ret.add($can:$spec, $desc:$matched.group(2) ?? "")
            }
        }
        return $ret
    })

    compdef --cmd fg --arg-func=$ff
    compdef --cmd bg --arg-func=$ff
    compdef --cmd disown --arg-func=$ff
    compdef --cmd jobs --arg-func=$ff
    for line in <(jobs -h) {
        var ret = $_option_pattern.match($line) ?? continue
        compdef --cmd jobs --short ${$ret.group(1)!} --arg-func $ff --desc ${$ret.group(2)!}
    }
}

## shctl
compdef --cmd=shctl --subcmd=is-interactive --arg-empty
compdef --cmd=shctl --subcmd=is-sourced --arg-empty
compdef --cmd=shctl --subcmd=backtrace --arg-empty
compdef --cmd=shctl --subcmd=function --arg-empty
compdef --cmd=shctl --subcmd=module --arg-action module
compdef --cmd=shctl --subcmd=set --arg-cmd 'shctl set | cut -d " " -f 1'
compdef --cmd=shctl --subcmd=set --short d  --arg-empty --desc 'dump current runtime options'
compdef --cmd=shctl --subcmd=set --short r  --arg-empty --desc 'restore runtime options'
compdef --cmd=shctl --subcmd=unset --arg-cmd 'shctl set | cut -d " " -f 1'
compdef --cmd=shctl --subcmd=info --arg-empty
compdef --cmd=shctl --subcmd=winsize --arg-empty
