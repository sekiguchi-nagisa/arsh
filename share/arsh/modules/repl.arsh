
# ignore err-raise at module loading time
let _old = { shctl set -d; $REPLY; }
defer { shctl set -r $_old; }
shctl unset errraise

# load default prompt setting
source $SCRIPT_DIR/repl_impl/prompt.arsh inlined

# load default history setting
source $SCRIPT_DIR/repl_impl/history.arsh inlined

# load key-bind manipulation
source $SCRIPT_DIR/repl_impl/bind.arsh inlined

# create DATA_HOME
test -e $DATA_HOME || mkdir -p $DATA_HOME || true

# prompt setting
var _once = $false
$LINE_EDIT.setPrompter(function(p) => {
    let old = $?
    if !$_once {
        $_once = $true
        try { $LOAD_HISTORY(); } catch e { $e.show(); } # load history at first prompt
        $? = $old
    }

    for hook in $PRE_PROMPTS {
        try { $hook(); } catch e { $e.show(); }
        $? = $old
    }
    try {
        $p = $PROMPT_HOOK ? $PROMPT_HOOK!($PS1) : $PS1
        if $PROMPT_RENDERER {
            $p = $PROMPT_RENDERER!($p)
        }
    } catch e {
        $e.show()
    }

    if let hook = $TITLE_HOOK {  # some terminal update active process name after receive OSC0
        $? = $old
        try {
            if var title = $hook() {
                printf $'\e]0;%s\a' $title >> /dev/tty || true
            }
        } catch e { $e.show(); }
    }

    $p
})

# history setting
$LINE_EDIT.setAcceptor(function(line, buf) => {
    let old = $?
    try {
        if let hist = $buf {
            $APPEND_HISTORY($hist, $line)
        }
        $? = $old
    } catch e { $e.show(); }

    for hook in $PRE_EXECS {
        try { $hook(); } catch e { $e.show(); }
        $? = $old
    }
})

# completion setting
$LINE_EDIT.setCompleter(function(m, s) => {
    complete -m $m -q -s -d -- $s
    $COMPREPLY
})
source $SCRIPT_DIR/../completions/*.arsh

# ISDIR setting
source $SCRIPT_DIR/cnf.arsh inlined
$ISDIR_HOOK = function($s : String) => cd $s && pwd

# syntax highlight color setting
if(command -v arcolorize &>> /dev/null) {
    var format = "term256"
    if getenv COLORTERM && $REPLY == 'truecolor' {
        $format = "term"
    }
    if getenv TERM && $REPLY.contains('screen') {
        $format = "term256"
    }
    var color = "$(arcolorize --dump -s monokai_dimmed -f $format 2>> /dev/null)"
    if $? == 0 {
        $LINE_EDIT.config('color', $color)
    }
}

# enable fzf integration
source $SCRIPT_DIR/fzf.arsh

# handle SIGHUP (for termination handler invocation at logout)
$SIGHUP.trap($SIG_EXIT)

# enable token-aware actions
{
    var binding: [String:String]
    for k,a in $LINE_EDIT.bindings() {
        if $a.contains("word") {
            $binding[$k] = $a.replace("word", "token")
        }
    }

    for k, a in $binding {
        $LINE_EDIT.bind($k, $a)
    }
}

# edit-command-line
function _edit_command_line(line : String, list : [String]?) : String? {
    var editor = (getenv VISUAL) ? $REPLY : (getenv EDITOR) ? $REPLY
                : { echo 1>&2 $'\n'environmental variable \$VISUAL or \$EDITOR not set;  return $none; }
    var tmp = "$(mktemp)".ifEmpty() ?? return $none
    defer { rm -rf $tmp || true; }
    printf "%s" $line > $tmp
    call $editor $tmp || return $none
    return IFS=$'\n' "$(cat $tmp)"
}

$LINE_EDIT.action('edit-command-line', 'replace-whole', $_edit_command_line)
$LINE_EDIT.bind('^[e', 'edit-command-line') # ALT-e