#!/usr/bin/env arsh

function _escape(s : String) : String {
    var ret = ""
    let size = $s.size()
    for(var i = 0; $i < $size; $i++) {
        var ch = $s[$i]
        if $ch == '\' {
            $ret += '\'
        }
        $ret += $ch
    }
    return $ret
}

let _cache = [
    'c' : '\\c',
    'h' : $_escape("$(uname -n)").split(".")[0],
    'H' : $_escape("$(uname -n)"),
    's' : $_escape($0.basename()),
    'u' : $_escape("$(whoami)"),
    'v' : $YDSH_VERSION.slice(0, $YDSH_VERSION.lastIndexOf('.')),
    'V' : $YDSH_VERSION,
    '$' : $UID == 0 ? '#' : '$',
]

let _home = @(~)[0]

## bash-compatible prompt interpreter

function renderPrompt(p : String) : String {
    let old_reply = $reply.copy()
    defer {
        $reply.clear()
        $reply.addAll($old_reply) # restore reply
    }

    importenv PWD : "."
    var ret = ""
    let size = $p.size()
    let key = "_" + $RANDOM % 1000000000
    for(var i = 0; $i < $size; $i++) {
        var ch = $p[$i]
        if $ch == '\' && $i + 1 < $size {
            $i++
            var k = $p[$i]
            case $k {
            'd' => {
                LANG=C printf -v $key '%(%a %m %d)T'
                $ch = $reply.remove($key)!
            }
            't' => { 
                printf -v $key '%(%T)T'
                $ch = $reply.remove($key)!
            }
            'T' => { 
                printf -v $key '%(%I:%M:%S)T'
                $ch = $reply.remove($key)!
            }
            '@' => {
                LANG=C printf -v $key '%(%I:%M %p)T'
                $ch = $reply.remove($key)!
            }
            'w' => {
                if $PWD.startsWith($_home) {
                    $ch = "~" + $_escape($PWD.slice($_home.size()))
                } else {
                    $ch = $_escape($PWD)
                }
            }
            'W' => {
                if $PWD == "." { $ret += '.'; continue; }
                if $_home == $PWD {
                    $ch = "~"
                } else {
                    $ch = $_escape($PWD.basename())
                }
            }
            '[' | ']' => continue;
            '\' => { $ret += '\'; }
            else => $ch = $_cache.get($k) ?? { $i--; $ch; }
            }
        }
        $ret += $ch
    }
    printf -v $key "%b" $ret
    return $reply.remove($key)!
}

function _usage(fd : UnixFD, short : Boolean) : Int  {
    echo >& $fd usage: prompt [-h] [--help] [prompt]
    if $short { return 2; }

    echo >& $fd "Prompt Escape Sequence:
    \a    bell
    \d    date
    \e    escape sequence
    \h    host name
    \H    fully qualified host name
    \n    newline
    \r    carriage return
    \s    base name of \$0
    \t    24 hour notation (HH:MM:SS)
    \T    12 hour notation (HH:MM:SS)
    \@    12 hour notation with AM/PM
    \u    user name
    \v    version
    \V    version with patch level
    \w    current directory
    \W    base name of current directory(\$HOME is replaced by tilde)
    \\\$    # if uid is 0, otherwise \$
    \\\\    backslash
    \[    begin of unprintable sequence
    \]    end of unprintable sequence
    \0nnn N is octal number.  NNN can be 0 to 3 number
    \xnn  N is hex number.  NN can be 1 to 2 number"

    return 2;
}

prompt() {
    while($# > 0) {
        case $1 {
            '-h' | '--help' => return $_usage($STDOUT, $false); 
            '--' => { $@.shift(); break; }
            else => {
                if $1.startsWith('-') {
                    echo >& $STDERR prompt: $1: invalid option;
                    return $_usage($STDERR, $true);
                }
                break
            }
        }
    }
    $1 :- return 0
    printf -- "%s\n" $renderPrompt($1)
    return 0
}