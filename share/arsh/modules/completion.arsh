
# for tab completion

type Completer = (Module, [String], Int) -> Candidates?

let _compMap : [String : Completer]

let _argFuncs : [String : (String) -> Candidates]  # prefix -> (filtered) candidate

function _defaultHook(ctx : Module, words : [String], cursor : Int) : Candidates? {
    if (command -v $words[0] &>> /dev/null) {
        var cmd = $words[0]
        if !$cmd.contains($'\0') {
            $cmd = $cmd.basename();
            if ($OSTYPE == 'cygwin' || $OSTYPE == 'msys') && $cmd.endsWith(".exe") {
                $cmd = $cmd.slice(0, -4)
            }
        }
        $words[0] = $cmd
        var comp = $_compMap.get($cmd) ?? $_compMap.get("") ?? function(m, w, c) => $none
        return $comp($ctx, $words, $cursor)
    }
    return $none
}

# if $cmd is empty string, treat as fallback handler
function compAdd(cmd : String, comp : Completer) : Completer? {
    $COMP_HOOK = $_defaultHook
    return $_compMap.put($cmd, $comp)
}


# for completion helper

type _CompDefEntry(t : Int?, a : String?, d: String?, o: Bool?) {
    let argType = $t ?? -1  # arg type (-1: empty, 0: list, 1: cmdline, 2: action, 3: comp, 4: func, 5: raw_func)
    let arg = $a ?? ""      # argument (for argument completion)
    let desc = $d           # description
    let opt = $o ?? $false  # for short optional (-s[arg]). 
}

type _CompDef() {
    let entries : [ 
        String : # option (short: starts with '-', long: starts with '--', arg: empty, path: starts with '/')
        _CompDefEntry
    ]
    var sort = $true
    var subcmds: [String : _CompDef]?
}

function getFirst(): (String, _CompDefEntry)? for _CompDef {
    return for e in $this.entries { break $e; }
}

function _should_tilde_expand(optToken: String): Bool {
    var count = 0
    if $optToken.endsWith('=') {
        let limit = - $optToken.size() - 1
        for(var i = -2; $i > $limit; $i--) {
            if $optToken[$i] == '\' {
                $count++
            } else {
                break
            }
        }
    }
    return $count %2 == 0
}

function generate(ctx: Module, optToken: String, prefixToken: String, allowOptShort: Bool): Candidates? for _CompDefEntry {
    if $this.opt && !$allowOptShort {
        return $none
    }
    let arg = $this.arg
    let prefix = $prefixToken.dequote()
    return case $this.argType {
        0 => {
            var r : Candidates
            for a in $arg.split(" ") {
                $a.empty() && continue
                if $a.startsWith($prefix) {
                    $r.add($a)
                }
            }
            $r.quote($prefixToken)
            $r
        }
        1 => {
            var ret : Candidates
            for line in <(call $BIN_NAME -c "$arg") {
                if $line.startsWith($prefix) {
                    $ret.add($line)
                }
            }
            $ret.quote($prefixToken)
            $ret
        }
        2 => {
            var actions : [String]
            for a in $arg.split("|") {
                $a.empty() && continue
                $actions.add("-A")
                $actions.add($a)
            }
            if $prefixToken.startsWith('~') && $_should_tilde_expand($optToken) {
                $actions.add('-A').add('tilde')
            }
            complete -q -m $ctx -Q $actions -- $prefixToken;
            $COMPREPLY
        }
        4 => {
            if $arg.empty() {
                new Candidates()
            } else {
                var func = $_argFuncs.get($arg) ?? return $none
                var ret = $func($prefix)
                $ret.quote($prefixToken)
                $ret
            }
        }
        5 => {
            if $arg.empty() {
                new Candidates()
            } else {
                var func = $_argFuncs.get($arg) ?? return $none
                $func($prefixToken)  # pass raw word
            }
        }
        else => $none
    }
}

let _compdefMap : [String : _CompDef] # command name to completion definition mapping

function _remove_prefix_from_quoted(quoted: String, n: Int): String {
    var index = 0
    let size = $quoted.size()
    for (var count = 0; $count < $n && $index < $size; $index++) {
        var ch = $quoted[$index]
        if $ch == '\' && $index + 1 < $size {
            $index++
            $quoted[$index] == $'\n' && continue
        }
        $count++
    }
    return $quoted.slice($index)
}

#
# $prefix starts with '-'
# return raw candidates (not quoted)
#
function _comp_opt(deflist : _CompDef, prefix : String) : Candidates {
    var ret = new Candidates($sort:$deflist.sort)
    for option, def in $deflist.entries {
        $option.startsWith('-') || continue
        if $option.startsWith($prefix) {
            var long = $option.endsWith('=') && $option.size() > 2 # --opt=, -opt=
            $ret.add($option, $space: $long ? 0 : -1, $desc: $def.desc)
        } elif $prefix.startsWith($option) && $def.argType != -1 { 
            if $option.size() > 2 { # --opt=arg, -opt=arg
                # opt -> --opt, -opt
                # prefix -> --opt=hoge, -opt=hoge
                if ($prefix.slice($option.size()).startsWith('=') || $option.endsWith('=')) {
                    $ret.add($option, $desc: $def.desc)
                }
            } elif $def.opt { # -D[arg]
                # opt -> -O
                # prefix -> -Oarg
                $ret.add($option, $desc: $def.desc)
            }
        }
    }
    return $ret
}

#
# complete arguments of specified option
# $opt is empty string or starts with '-'
# return quoted candidates
#
function _comp_arg(ctx : Module, deflist: _CompDef, optToken: String, opt : String, prefixToken : String, allowOptShort: Bool?) : Candidates? {
    if let def = $deflist.entries.get($opt) {
        return $def.generate($ctx, $opt.empty() ? "" : $optToken, $prefixToken, $allowOptShort ?? $false)
    }
    if $opt.empty() && $deflist.subcmds { # complete sub-command
        let prefix = $prefixToken.dequote()
        var can : Candidates
        for cmd, _ in $deflist.subcmds {
            if $cmd.startsWith($prefix) {
                $can.add($cmd)
            }
        }
        $can.quote($prefixToken)
        return $can
    }
    return $none
}

let _help_comp_targets = @(
    a2ps awk base64 bash bc bison cat chroot colordiff cp
    csplit cut date df diff dir du enscript expand fmt fold gperf
    grep grub head irb ld ldd less ln m4 mkdir mkfifo mknod
    mv nl nm objcopy objdump od paste pr ptx readelf
    sed shar sort split strip sum tac tail tee
    texindex touch tr unexpand uniq vdir wc who ls rm rmdir
    env netstat seq uname units
).sort()

function _comp_opt_by_help(argv: [String], cursor: Int): Candidates? {
    let cmd = $argv[0]
    $_help_comp_targets.searchSorted($cmd) < 0 && return $none
    command -v $cmd &>> /dev/null || return $none
    let wordToken = $cursor < $argv.size() ? $argv[$cursor] : return $none
    let word = $wordToken.dequote()
    $word.startsWith('-') || return $none
    var can: Candidates
    var proc = <(LANG=C call $cmd --help 2>> /dev/null)
    for line in $proc {
        $/^ *[-][-a-zA-Z0-9]/ =~ $line || continue

        var matched = $/^ *((?<short>[-][a-zA-Z]),? *)?(?<long>[-][-][a-zA-Z0-9-]+=?)?/.match($line) ?? continue
        if let short = $matched.named("short") {
            if $short.startsWith($word) {
                $can.add($short)
            }
        }
        if let long = $matched.named("long") {
            if $word.startsWith($long) && $long.endsWith('=') {
                return $none
            }
            if $long.startsWith($word) {
                var sp = $long.endsWith("=") ? 0:1
                $can.add($long, $space:$sp)
            }
        }
    }
    $can.quote($wordToken)
    return $can.size() == 0 && $proc.job().wait() != 0 ? $none : $can
}

let INSTALL_PREFIX = $DATA_DIR.dirname().dirname()

let _bash_completion_dirs = [
    '/usr/local/etc/bash_completion.d/',
    '/usr/local/share/bash-completion/completions/',

    '/opt/homebrew/etc/bash_completion.d/',
    '/opt/homebrew/share/bash-completion/completions/',

    "${$INSTALL_PREFIX == '/usr' ? '' : $INSTALL_PREFIX}/etc/bash_completion.d/",
    "$INSTALL_PREFIX/share/bash-completion/completions/",
    '/etc/bash_completion.d/',
    '/usr/share/bash-completion/completions/',
]

function findBashCompScript(name : String) : String? {
    $name.contains($'\0') && return $none
    for dir in $_bash_completion_dirs {
        var path = $dir + $name
        test -f $path && return $path
    }
    return $none
}

let _bash_completion_paths = [
    "/usr/local/share/bash-completion/bash_completion",
    "/opt/homebrew/share/bash-completion/bash_completion",
    "/usr/share/bash-completion/bash_completion",
    "$INSTALL_PREFIX/share/bash-completion/bash_completion",
]

var BASH_COMPLETION_PATH = "/usr/share/bash-completion/bash_completion"
var BASH_COMPLETION_COMPAT = "/etc/bash_completion.d/000_bash_completion_compat.bash"

# Conceptually based on git-completion.tcsh 
# (https://github.com/git/git/blob/master/contrib/completion/git-completion.tcsh)
function _comp_wrap(file : String, target : String, words : [String], cursor : Int): Candidates? {
    test -f $file || return $none
    if !(test -f $BASH_COMPLETION_PATH) {
        $BASH_COMPLETION_PATH = 
            for path in $_bash_completion_paths {
                test -f $path && break $path
            } ?? return $none
    }
    if !(test -f $BASH_COMPLETION_COMPAT) {
        $BASH_COMPLETION_COMPAT = $findBashCompScript("000_bash_completion_compat.bash") ?? ""
    }

    let script = '
    complete() { true; }   # ignore `complete` function
    compopt() { true; }    # FIXME: emulate `-o option`
    BASH_COMPLETION_COMPAT_DIR=/dev/null
    BASH_COMPLETION_USER_FILE=/dev/null

    bash_completion_path="$1"
    comp_script="$2"
    comp_func="$3"
    bash_completion_compat="$4"
    COMP_CWORD="$5"
    shift 5
    COMP_WORDS=("$@")
    if [ ${#COMP_WORDS[@]} -eq $COMP_CWORD ]; then
        COMP_WORDS+=("")
    fi
    COMP_LINE="${COMP_WORDS[@]}"
    COMP_POINT=${#COMP_LINE}

    # load script and call completion function
    source "$bash_completion_path"
    if [ "x${bash_completion_compat}" != x ]; then
        source "$bash_completion_compat"   # for bash-completion v2.12
        if ! declare -f _split_longopt &>> /dev/null && declare -f _comp__split_longopt &>> /dev/null; then
            _comp_deprecate_func 2.12 _split_longopt _comp__split_longopt  # workaround for old completion script
        fi
    fi
    source "$comp_script"
    "$comp_func" "$(basename ${COMP_WORDS[0]})"

    for r in "${COMPREPLY[@]}"; do
        printf "%s\n" "$r"
    done
    '

    var wordToken = $words.peek()
    if $cursor >= $words.size() {
        $wordToken = ""
    }
    if $wordToken.endsWith('\') && !$wordToken.dequote().endsWith('\') {
        $words[-1] = $wordToken.slice(0,-1)  # force remove trailing backslash
    }

    $? = 0 # suppress error
    var ret : Candidates
    bash -c $script bash \
      $BASH_COMPLETION_PATH $file $target $BASH_COMPLETION_COMPAT $cursor $words | for line in $STDIN {
        if test -d $line && $line[-1] != '/' && $line.contains('/') { # for directory
            $line += '/'
        }
        var r = $_format($line)
        $ret.add($r._0, $space:$r._1)
        $? = 0 # suppress error
    }
    $ret.quote($wordToken)
    return $ret.size() == 0 ? $none : $ret
}

# return -1: auto-detect, 0: nospace, 1: space
function _format(can: String): (String, Int) {
    test -e $can && return ($can, -1) # if file. (ideally, should recognize `complete/compgen -o` options)
    var space = -1
    if $can.endsWith(' ') {
        $space = 1
        $can = $can.slice(0,-1) # trim suffix space
    } elif $can.startsWith('--') && $can.endsWith('=') { # `--long=`, suppress space insertion
        $space = 0
    }
    return ($can, $space)
}

# extract completion target (func, cmd). ex `complete -o default -F func cmd`
# if found, return (func, cmd)
function extractCompTarget(path : String, target_cmd: String?) : (String, String)? {
    var func : String?
    var cmd : String?

    for line in $STDIN {
        var rr = $/ *complete( +.+)? +-F +([^ $]+) +([^ ]+)/.match($line)
        if let r = $rr {
            $func = $r.group(2) ?? continue
            $cmd = $r.group(3) ?? continue
            if let tc = $target_cmd {
                if $tc != $cmd! {
                    continue
                }
            }
            break
        }
    } with < $path
    return $func && $cmd ? ($func!, $cmd!) : $none
}

# for lazy loading bash completion script
function _comp_autoload(cmd : String) : String? {
    var path = $findBashCompScript($cmd) ?? return $none
    var target = $extractCompTarget($path, $cmd)
    if let tt = $target {
        call compdef --cmd $cmd --comp-path $cmd --comp-target ${tt._0} && return $cmd
    }
    return $none
}

function _from_compdef(ctx : Module, words : [String], cursor : Int) : Candidates? {
    var cmd = $words[0]
    var deflist = $_compdefMap.get($cmd) ?? {
        $cmd = $_comp_autoload($cmd) ?? return $_comp_opt_by_help($words, $cursor)
        $_compdefMap[$cmd]
    }
    # resolve sub-command def
    # 'CMD sub1 '
    # 'CMD sub1 -d'
    while $deflist.subcmds && $words.size() >= 2 && $cursor >= 2 {
        if let sub = $deflist.subcmds!.get($words[1].dequote()) {
            $deflist = $sub
            $words.shift()
            $cursor--
        } else {
            break
        }
    }

    if let e = $deflist.getFirst() {
        if $e._1.argType == 3 {
            return $_comp_wrap($e._0, $e._1.arg, $words, $cursor)
        }
    }
    if $words.size() == $cursor {    # complete arguments or options
        # 'CMD '
        # 'CMD arg '
        # 'CMD -s '
        var prevToken = ($words.size() == 1 ? "" : $words[-1])
        var prev = $prevToken.dequote()
        return $_comp_arg($ctx, $deflist, $prevToken, $prev.startsWith("-") ? $prev : "", "")
    } else {
        # 'CMD d'
        # 'CMD -'
        # 'CMD --d'
        # 'CMD' --dump=s
        # 'CMD -s d'
        # 'CMD arg1 d'
        assert $words.size() > 1
        let prevToken = $words[-1]
        var prev = $prevToken.dequote()
        if $prev.startsWith('-') { # 'CMD -', 'CMD --d'
            var ret = $_comp_opt($deflist, $prev)
            if $ret.size() == 1 {
                var opt = $ret[0]
                if $prev.startsWith($opt) {
                    # for `--opt=' or `-opt=' style option
                    if $opt.endsWith('=') && $opt.size() > 2 {  # defined as `--long opt=' or `--long-single opt=` form
                        var prefixToken = $_remove_prefix_from_quoted($prevToken, $opt.size())
                        var optToken = $prevToken.slice(0, $prevToken.size() - $prefixToken.size())
                        return $_comp_arg($ctx, $deflist, $optToken, $opt, $prefixToken)
                    }
                    if $prev.slice($opt.size()).startsWith('=') {  # -option=arg, --option=arg
                        var prefixToken = $_remove_prefix_from_quoted($prevToken, $opt.size() + 1)
                        var optToken = $prevToken.slice(0, $prevToken.size() - $prefixToken.size())
                        return $_comp_arg($ctx, $deflist, $optToken, $opt, $prefixToken)
                    }
                    if $opt.size() == 2 {
                        if let e = $deflist.entries.get($opt) {
                            if $e.opt {
                                var prefixToken = $_remove_prefix_from_quoted($prevToken, $opt.size())
                                var optToken = $prevToken.slice(0, $prevToken.size() - $prefixToken.size())
                                return $_comp_arg($ctx, $deflist, $optToken, $opt, $prefixToken, $true)
                            }
                        }
                    }
                }
            }
            $ret.quote($prevToken)
            return $ret
        }
        var optToken = ($words.size() == 2 ? "" : $words[-2])
        var opt = $optToken.dequote()
        return $_comp_arg($ctx, $deflist, $optToken, $opt.startsWith("-") ? $opt : "", $prevToken)
    }
}

[<CLI()>]
type _CompDefParam() {
    [<Option(required: $true, placeholder: "COMMAND", help: "set target command")>]
    var cmd = ''

    [<Option(placeholder: "SUBCMD...", help: "set target sub-command (null deliminated list)")>]
    var subcmd : String?

    [<Flag(help: "disable sorting of candidate")>]
    var nosort = $false

    [<Option(placeholder: "SHORT_OPTION", xor: 0, help: "set short option (start with '-')")>]
    var short : String?

    [<Option(placeholder: "LONG_OPTION", xor: 0, help: "set long option (start with '--')")>]
    var long: String?

    [<Option(placeholder: "LONG_SIGLE_DASH", xor: 0, help: "set long option with single dash")>]
    var long_single: String?

    [<Option(placeholder: "SHORT_OPTION", xor:0, help: "set short option taking optional argument (start with '-')")>]
    var short_opt: String?

    [<Option(placeholder: "LIST", xor: 1, help: "generate candidates from LIST split by ' '")>]
    var arg_list: String?

    [<Option(placeholder: "CMDLINE", xor: 1, help: "generate candidates from CMDLINE evaluation")>]
    var arg_cmd: String?

    [<Option(placeholder: "ACTION", xor: 1, help: "generate candidates from ACTION")>]
    var arg_action: String?

    [<Option(placeholder: "FUNC", xor: 1, help: "generate candidate from specified FUNC call (pass de-quoted word)")>]
    var arg_func: String?

    [<Option(placeholder: "FUNC", xor:1, help: "generate candidate from specified FUNC call (pass quoted word)")>]
    var arg_raw_func: String?

    [<Flag(xor: 1, help: "not generate candidates (empty candidate)")>]
    var arg_empty = $false

    [<Option(placeholder: "SCRIPT", xor: 0, help: "set bash completion script")>]
    var comp_path: String?

    [<Option(placeholder: "TARGET", xor: 1, help: "set bash completion function")>]
    var comp_target: String?

    [<Option(placeholder: "DESC", help: "specify option description")>]
    var desc: String?
}

function _error($p : _CompDefParam, $msg : String) : Int {
    echo 1>&2 ${$p.usage($msg)}
    return 1
}

compdef(param : _CompDefParam) {
    $compAdd("", $_from_compdef)

    var opt = $false
    var option = ""
    if let short = $param.short {
        if $short.size() > 1 {
            return $_error($param, "\`--short' option only accept single ascii char: \`$short'")
        }
        $option = '-'+ $short
    }
    if let long = $param.long {
        $option = '--' + $long
    }
    if let longSingle = $param.long_single {
        $option = '-' + $longSingle
    }
    if let shortOpt = $param.short_opt {
        if $shortOpt.size() > 1 {
            return $_error($param, "\`--short-opt' option only accept single ascii char: \`$shortOpt'")
        }
        $option = '-'+ $shortOpt
        $opt = $true
    }
    var argType : Int?
    var arg : String?
    if var path = $param.comp_path {
        if !$path.contains('/') {  # if not full-path, resolve full-path
            $path = $findBashCompScript($path) ?? return 1  # do nothing
        }
        if let target = $param.comp_target {
            $argType = 3
            $option = $path
            $arg = $target
        } else {
            return $_error($param, "need \`--comp-target' option")
        }
    } elif let arg_list = $param.arg_list {
        $argType = 0
        $arg = $arg_list
    } elif let arg_cmd = $param.arg_cmd {
        $argType = 1
        $arg = $arg_cmd
    } elif let arg_action = $param.arg_action {
        $argType = 2
        $arg = $arg_action
    } elif let arg_func = $param.arg_func {
        $argType = 4
        $arg = $arg_func
    }elif let arg_func = $param.arg_raw_func {
        $argType = 5
        $arg = $arg_func
    } elif $param.arg_empty {
        $argType = 4
        $arg = ''
    }

    var def = $_compdefMap.get($param.cmd) ?? {
        var tmp : _CompDef
        $_compdefMap[$param.cmd] = $tmp
        $tmp
    }
    if let subs = $param.subcmd {
        for sub in $subs.split($'\0') {
            $sub.ifEmpty() ?? continue
            $/^[a-zA-Z0-9_][a-zA-Z0-9_-]*$/ =~ $sub || 
                return $_error($param, "--subcmd option only accept valid sub-command names: $sub")
            let subcmds = $def.subcmds ?? {
                var m = new [String : _CompDef]()
                $def.subcmds = $m
                $m
            }
            $def = $subcmds.get($sub) ?? {
                var f = new _CompDef()
                $subcmds[$sub] = $f
                $f
            }
        }
    }

    if $param.nosort {
        $def.sort = $false
    }
    if $def.entries.put($option, new _CompDefEntry($argType, $arg, $param.desc, $opt)) {
        return $_error($param, "already defined option: \`$option' for \`${param.cmd}'")
    }
    return 0
}

function compDelegate(ctx : Module, words : [String], cursor : Int) : Candidates? {
    return $_defaultHook($ctx, $words, $cursor)
}

function compAlias(cmd: String, target: String): Completer? {
    return $compAdd($cmd, function(ctx, words, cursor) =>{
        $words[0] = $target
        $compDelegate($ctx, $words, $cursor)
    })
}

function bindArgFunc(func: (String)-> Candidates): String {
    let key = for(var i = 10000; $i< 1000000000000000000;$i*=10) {
        let key = "af${$RANDOM % $i}"
        $_argFuncs.get($key) ?? break $key
    } ?? "af$RANDOM"
    $_argFuncs[$key] = $func
    return $key
}