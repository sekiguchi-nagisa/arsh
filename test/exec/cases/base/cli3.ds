
# for user-defined command with parameter

[<CLI(verbose: $true)>]
typedef CCC() {
  [<Arg(required: $true, range:(120,-10))>]
  var aaa : Int?

  [<Arg(required: $false)>]
  var bbb : String?

  var dummy = "dummy"

  [<Arg(required: $true)>]
  var ccc : [String]

  [<Flag(short: 'd', long: "debug", help: "enable debug mode")>]
  var d = $false
}

[<CLI(name: $'default\x00!!', verbose: $true)>]
typedef DDD() {}

assert (new CCC()) is CLI
assert (new DDD()) is CLI
var dd = new DDD()
assert $dd.name() == $'default\x00!!'
assert $dd.usage("must be valid argument") == "must be valid argument
Usage: default${$'\x00'}!!

Options:
  -h, --help  show this help message"

ff(p : CCC) {
  assert $p.name() == 'ff'  # if not specified `name` attribute (name is empty), set to $0
  echo $p
}
gg(p : DDD) {
  assert $p.name() == $'default\x00!!'  # if specified `name` attribute (name is not empty) always set to $0
  echo $p
}

## successful parsing
var r = "$(ff 100 10 a b c)"
assert $r == "ff 100 10 dummy a b c false" : $r
$r = "$(gg 1 2 3)"
assert $r == $'default\x00!!' : $r

## help
$r = "$(ff --help)"
assert $r == "Usage: ff [OPTIONS] AAA [BBB] CCC...

Options:
  -d, --debug  enable debug mode
  -h, --help   show this help message"
assert $? == 0

## error
$r = "$(ff --ss 2>&1)"
assert $r == "invalid option: --ss
Usage: ff [OPTIONS] AAA [BBB] CCC...

Options:
  -d, --debug  enable debug mode
  -h, --help   show this help message" : $r
assert $? == 2

$r = "$(ff sss 2>&1)"
assert $r == "invalid argument: \`sss', must be decimal integer
Usage: ff [OPTIONS] AAA [BBB] CCC...

Options:
  -d, --debug  enable debug mode
  -h, --help   show this help message" : $r
assert $? == 1

## errraise
shctl set errraise

var ex = 34 as Any
try {
  ff --ss
} catch e {
  $ex = $e
}
assert $ex is ExecError
assert ($ex as ExecError).status() == 2
assert ($ex as ExecError).lineno() == 82

true