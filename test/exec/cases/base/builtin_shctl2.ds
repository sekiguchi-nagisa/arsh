
# for option query/setting
# show option setting
assert shctl set
assert shctl set | grep 'traceonexit *  off'
assert shctl set | grep 'monitor *  off'
assert shctl set | grep 'clobber *  on'
shctl set | grep 'assert.*  on' || _exit

# set
assert shctl set traceonexit
assert shctl set | grep 'traceonexit *  on'
assert shctl set TRAC-E_ON_Exit tracE_onexit
assert shctl set | grep 'traceonexit *  on'

assert shctl set HUGA 2>&1 | grep 'ydsh: shctl: unrecognized runtime option: HUGA'
shctl set HUGA
assert $? == 1

# unset
assert shctl unset traceonexit
assert shctl set | grep 'traceonexit *  off'
assert shctl unset traceonexit traceonexit
assert shctl set | grep 'traceonexit *  off'

assert shctl unset 2>&1 | grep "ydsh: shctl: \`unset' subcommand requires argument"
shctl unset
assert $? == 2

assert shctl unset HUGA 2>&1 | grep 'ydsh: shctl: unrecognized runtime option: HUGA'
shctl unset HUGA
assert $? == 1

## for `monitor' option
### in monitor off
assert $SIG['INT'].trap() == $SIG_DFL : "${$SIG['INT']}"
assert $SIG['QUIT'].trap() == $SIG_DFL
assert $SIG['TSTP'].trap() == $SIG_DFL
assert $SIG['TTIN'].trap() == $SIG_DFL
assert $SIG['TTOU'].trap() == $SIG_DFL

assert fg 2>&1 | grep 'ydsh: fg: no job control in this shell'
assert bg 2>&1 | grep 'ydsh: bg: no job control in this shell'

### in monitor on
shctl set monitor
assert $SIG['INT'].trap() != $SIG_IGN # set monitor, set internal sigint handler
assert $SIG['INT'].trap() != $SIG_DFL
assert $SIG['QUIT'].trap() == $SIG_IGN
assert $SIG['TSTP'].trap() == $SIG_IGN
assert $SIG['TTIN'].trap() == $SIG_IGN
assert $SIG['TTOU'].trap() == $SIG_IGN

assert fg 2>&1 | grep 'ydsh: fg: no job control in this shell'  # in subell, job control is disabled even if monitor option is enabled
assert bg 2>&1 | grep 'ydsh: bg: no job control in this shell'

## for `xtrace` option
assert shctl set | grep 'xtrace.*  off'
shctl set xtrace
assert "$(echo hello 2>&1 > /dev/null)" == "+ $SCRIPT_NAME:60> echo hello"
shctl unset xtrace
assert "$(echo hello 2>&1 > /dev/null)" == ""

## for `clobber` option
assert shctl set | grep 'clobber *  on'
var ex = 34 as Any
try { echo hello > /dev/null; } catch e { $ex = $e; }
assert $ex is Int
$ex = 34
try { echo hello >| /dev/null; } catch e { $ex = $e; }
assert $ex is Int
$ex = 34
try { echo hello &> /dev/null; } catch e { $ex = $e; }
assert $ex is Int
$ex = 34
try { echo hello &>| /dev/null; } catch e { $ex = $e; }
assert $ex is Int

shctl unset clobber
assert shctl set | grep 'clobber *  off'
$ex = 34
try { echo hello > /dev/null; } catch e { $ex = $e; }
assert $ex is SystemError
$ex = 34
try { echo hello >| /dev/null; } catch e { $ex = $e; }
assert $ex is Int
$ex = 34
try { echo hello &> /dev/null; } catch e { $ex = $e; }
assert $ex is SystemError
$ex = 34
try { echo hello &>| /dev/null; } catch e { $ex = $e; }
assert $ex is Int

# dump/restore
shctl set -d
var oldOpt = $REPLY
var oldOut = "$(shctl set)"
shctl set Do_tGlob Nu__Llglob_ tRaceON__exit _Fastg_lob
shctl set -d
assert $oldOpt != $REPLY
assert $oldOut != "$(shctl set)"

shctl set -r $oldOpt
shctl set -d
assert $oldOpt == $REPLY
assert $oldOut == "$(shctl set)"

## invalid dump format
assert "$(shctl set -r fjrafia 2>&1)" == "ydsh: shctl: invalid option format: fjrafia" 
assert $? == 1

assert "$(shctl set -r 'dotglob=off 222= nullglob=off' 2>&1)" == 
        "ydsh: shctl: invalid option format: 222=" 
assert $? == 1

assert "$(shctl set -r dotglob=offf 2>&1)" == "ydsh: shctl: invalid option format: dotglob=offf" 
assert $? == 1

assert "$(shctl set -r fjrafia=off 2>&1)" == "ydsh: shctl: unrecognized runtime option: fjrafia" 
assert $? == 1

assert shctl set -s  2>&1 | grep -- '-s: invalid option'
shctl set -s  2>&1
assert $? == 2

assert shctl set -r  2>&1 | grep -- '-r: option requires argument'
shctl set -r  2>&1
assert $? == 1

true